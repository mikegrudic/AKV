// This file was automatically generated by 'make' from file 'fly_spat_to_SH.gen.c'.
// To modify it, please consider modifying fly_spat_to_SH.gen.c
/*
 * Copyright (c) 2010-2013 Centre National de la Recherche Scientifique.
 * written by Nathanael Schaeffer (CNRS, ISTerre, Grenoble, France).
 * 
 * nathanael.schaeffer@ujf-grenoble.fr
 * 
 * This software is governed by the CeCILL license under French law and
 * abiding by the rules of distribution of free software. You can use,
 * modify and/or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * 
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 * 
 */

//////////////////////////////////////////////////

	static void GEN3(spat_to_SH_fly,NWAY,SUFFIX)(shtns_cfg shtns, double *Vr, complex double *Qlm, long int llim) {

	s2d *BrF;		// contains the Fourier transformed data
	double *alm, *al;
	s2d *wg, *ct, *st;
	long int nk, k, vnlat, l,m;
  #ifndef SHT_AXISYM
	s2d sgn_mask;
	unsigned imlim, im;
  #endif
  #if _GCC_VEC_
	rnd qq[2*llim];
  #else
	double qq[llim];
  #endif

	s2d rer[(NLAT_2+VSIZE-1)/VSIZE+NWAY*(VSIZE2/VSIZE)-1];
	s2d ror[(NLAT_2+VSIZE-1)/VSIZE+NWAY*(VSIZE2/VSIZE)-1];
  #ifndef SHT_AXISYM
	s2d rei[(NLAT_2+VSIZE-1)/VSIZE+NWAY*(VSIZE2/VSIZE)-1];
	s2d roi[(NLAT_2+VSIZE-1)/VSIZE+NWAY*(VSIZE2/VSIZE)-1];
  #endif

	BrF = (s2d *) Vr;
  #ifndef SHT_AXISYM
	if (shtns->fftc_mode >= 0) {
	    if (shtns->fftc_mode == 0) {	// in-place
			fftw_execute_dft(shtns->fftc,(complex double*)BrF, (complex double*)BrF);
		} else {	// alloc memory for the transpose FFT
			unsigned long nv = shtns->nspat /VSIZE;
			BrF = (s2d*) VMALLOC( nv * sizeof(s2d) );
			fftw_execute_split_dft(shtns->fftc, Vr+NPHI, Vr, ((double*)BrF)+1, ((double*)BrF));
	    }
	}
	imlim = MTR;
	#ifdef SHT_VAR_LTR
		if (imlim*MRES > (unsigned) llim) imlim = ((unsigned) llim)/MRES;		// 32bit mul and div should be faster
	#endif
  #endif

	vnlat = ((unsigned) NLAT)/VSIZE;		// vector size.
	nk = NLAT_2;	// copy NLAT_2 to a local variable for faster access (inner loop limit)
	wg = (s2d*) shtns->wg;		ct = (s2d*) shtns->ct;		st = (s2d*) shtns->st;
	#if _GCC_VEC_
	  nk = ((unsigned) nk+(VSIZE2-1))/VSIZE2;
	#endif
	//	im = 0;		// dzl.p = 0.0 : and evrything is REAL
		k=0;
		alm = shtns->blm[0];
		s2d r0 = vdup(0.0);
		do {	// compute symmetric and antisymmetric parts. (do not weight here, it is cheaper to weight y0)
			s2d a = BrF[k];		s2d b = vxchg(BrF[vnlat-1-k]);
			rer[k] = a+b;		ror[k] = a-b;
			r0 += (a+b)*wg[k];
		} while(++k < nk*(VSIZE2/VSIZE));
		for (k=nk*(VSIZE2/VSIZE); k<(nk+NWAY)*(VSIZE2/VSIZE)-1; ++k) {
			rer[k] = vdup(0.0);		ror[k] = vdup(0.0);
		}
		#if _GCC_VEC_
			Qlm[0] = (vlo_to_dbl(r0) + vhi_to_dbl(r0)) * alm[0];					// l=0 is done.
		#else
			Qlm[0] = r0 * alm[0];				// l=0 is done.
		#endif
		k = 0;
		for (l=0;l<llim;++l) {
			qq[l] = vall(0.0);
		}
		do {
			al = alm;
			rnd cost[NWAY], y0[NWAY], y1[NWAY];
			rnd rerk[NWAY], rork[NWAY];		// help the compiler to cache into registers.
			for (int j=0; j<NWAY; ++j) {
				cost[j] = vread(ct, k+j);
				y0[j] = vall(al[0]) * vread(wg, k+j);		// weight of Gauss quadrature appears here
				y1[j] =  (vall(al[1])*y0[j]) * cost[j];
				rerk[j] = vread(rer, k+j);		rork[j] = vread(ror, k+j);		// cache into registers.
			}
			al+=2;	l=1;
			while(l<llim) {
				for (int j=0; j<NWAY; ++j) {
					y0[j]  = vall(al[1])*(cost[j]*y1[j]) + vall(al[0])*y0[j];
				}
				for (int j=0; j<NWAY; ++j) {
					qq[l-1] += y1[j] * rork[j];
				}
				for (int j=0; j<NWAY; ++j) {
					y1[j]  = vall(al[3])*(cost[j]*y0[j]) + vall(al[2])*y1[j];
				}
				for (int j=0; j<NWAY; ++j) {
					qq[l] += y0[j] * rerk[j];
				}
				al+=4;	l+=2;
			}
			if (l==llim) {
				for (int j=0; j<NWAY; ++j) {
					qq[l-1] += y1[j] * rork[j];
				}
			}
			k+=NWAY;
		} while (k < nk);
		for (l=1; l<=llim; ++l) {
			#if _GCC_VEC_
			  #ifdef __AVX__
			    s2d qa = _mm256_castpd256_pd128(qq[l-1]) + _mm256_extractf128_pd(qq[l-1],1);
				Qlm[l] = vlo_to_dbl(qa) + vhi_to_dbl(qa);
			  #elif defined __SSE3__
				Qlm[l] = vlo_to_dbl(qq[l-1]) + vhi_to_dbl(qq[l-1]);
			  #else
				Qlm[l] = vlo_to_dbl(qq[l-1]) + vhi_to_dbl(qq[l-1]);
			  #endif
			#else
				Qlm[l] = qq[l-1];
			#endif
		}
		#ifdef SHT_VAR_LTR
			for (l=llim+1; l<= LMAX; ++l) {
				Qlm[l] = 0.0;
			}
		#endif

  #ifndef SHT_AXISYM
	#if _GCC_VEC_
		sgn_mask = SIGN_MASK_HI;		// build mask to change sign of hi value using xorpd (used in CFFT_TO_2REAL)
	#endif
	for (k=nk*(VSIZE2/VSIZE); k<(nk+NWAY)*(VSIZE2/VSIZE)-1; ++k) {		// never written, so this is now done for all m's (real parts already zero)
		rei[k] = vdup(0.0);		roi[k] = vdup(0.0);
	}
	for (im=1;im<=imlim;++im) {
		BrF += vnlat;
		l = shtns->tm[im] / VSIZE2;
		alm = shtns->blm[im];
		m = im*MRES;
 	#if _GCC_VEC_
 		k=(VSIZE2/VSIZE)*l;
		do {	// compute symmetric and antisymmetric parts, and reorganize data.
			s2d nr, ni, sr, si, tn, ts;
			ni = BrF[k];				nr = BrF[(NPHI-2*im)*vnlat + k];
			si = BrF[vnlat-1 - k];		sr = BrF[(NPHI-2*im)*vnlat +vnlat-1-k];
			CFFT_TO_2REAL(nr, ni, sr, si, sgn_mask)
			rer[k] = nr+sr;		ror[k] = nr-sr;		rei[k] = ni+si;		roi[k] = ni-si;


		} while(++k < nk*(VSIZE2/VSIZE));
	#else
		k = (l>>1)*2;		// k must be even here.
		do {	// compute symmetric and antisymmetric parts, and reorganize data.
			double an, bn, ani, bni, bs, as, bsi, asi, t;
			ani = BrF[k];		bni = BrF[k+1];		// north
			an = BrF[(NPHI-2*im)*vnlat + k];	bn = BrF[(NPHI-2*im)*vnlat + k+1];
			t = ani-an;	an += ani;		ani = bn-bni;		bn += bni;		bni = t;
			bsi = BrF[vnlat-2 -k];	asi = BrF[vnlat-1 -k];	// south
			bs = BrF[(NPHI-2*im)*vnlat +vnlat-2-k];		as = BrF[(NPHI-2*im)*vnlat +vnlat-1-k];
			t = bsi-bs;		bs += bsi;		bsi = as-asi;		as += asi;		asi = t;
			rer[k] = an+as;		rei[k] = ani+asi;		rer[k+1] = bn+bs;		rei[k+1] = bni+bsi;
			ror[k] = an-as;		roi[k] = ani-asi;		ror[k+1] = bn-bs;		roi[k+1] = bni-bsi;


			k+=2;
 		} while (k<nk);
	#endif
		k=l;
		#if _GCC_VEC_
			rnd* q = qq;
		#else
			l = LiM(shtns, m, im);
			double* q = (double *) &Qlm[l];
		#endif
		for (l=llim-m; l>=0; l--) {
			q[0] = vall(0.0);		q[1] = vall(0.0);		q+=2;
		}
		do {
		#if _GCC_VEC_
			rnd* q = qq;
		#else
			l = LiM(shtns, m, im);
			double* q = (double *) &Qlm[l];
		#endif
			al = alm;
			rnd cost[NWAY], y0[NWAY], y1[NWAY];
			rnd rerk[NWAY], reik[NWAY], rork[NWAY], roik[NWAY];		// help the compiler to cache into registers.
			for (int j=0; j<NWAY; ++j) {
				cost[j] = vread(st, k+j);
				y0[j] = vall(0.5);
			}
			l=m;
			long int ny = 0;	// exponent to extend double precision range.
		if ((int)llim <= SHT_L_RESCALE_FLY) {
			do {		// sin(theta)^m
				if (l&1) for (int j=0; j<NWAY; ++j) y0[j] *= cost[j];
				for (int j=0; j<NWAY; ++j) cost[j] *= cost[j];
			} while(l >>= 1);
		} else {
			long int nsint = 0;
			do {		// sin(theta)^m		(use rescaling to avoid underflow)
				if (l&1) {
					for (int j=0; j<NWAY; ++j) y0[j] *= cost[j];
					ny += nsint;
					if (vlo(y0[0]) < (SHT_ACCURACY+1.0/SHT_SCALE_FACTOR)) {
						ny--;
						for (int j=0; j<NWAY; ++j) y0[j] *= vall(SHT_SCALE_FACTOR);
					}
				}
				for (int j=0; j<NWAY; ++j) cost[j] *= cost[j];
				nsint += nsint;
				if (vlo(cost[0]) < 1.0/SHT_SCALE_FACTOR) {
					nsint--;
					for (int j=0; j<NWAY; ++j) cost[j] *= vall(SHT_SCALE_FACTOR);
				}
			} while(l >>= 1);
		}
			for (int j=0; j<NWAY; ++j) {
				y0[j] *= vall(al[0]);
				cost[j] = vread(ct, k+j);
				y1[j]  = (vall(al[1])*y0[j]) *cost[j];
			}
			l=m;	al+=2;
			while ((ny<0) && (l<llim)) {		// ylm treated as zero and ignored if ny < 0
				for (int j=0; j<NWAY; ++j) {
					y0[j] = vall(al[1])*(cost[j]*y1[j]) + vall(al[0])*y0[j];
				}
				for (int j=0; j<NWAY; ++j) {
					y1[j] = vall(al[3])*(cost[j]*y0[j]) + vall(al[2])*y1[j];
				}
				l+=2;	al+=4;
				if (fabs(vlo(y0[NWAY-1])) > SHT_ACCURACY*SHT_SCALE_FACTOR + 1.0) {		// rescale when value is significant
					++ny;
					for (int j=0; j<NWAY; ++j) {
						y0[j] *= vall(1.0/SHT_SCALE_FACTOR);		y1[j] *= vall(1.0/SHT_SCALE_FACTOR);
					}
				}
			}
		  if (ny == 0) {
			q+=2*(l-m);
			for (int j=0; j<NWAY; ++j) {	// prefetch
				y0[j] *= vread(wg, k+j);		y1[j] *= vread(wg, k+j);		// weight appears here (must be after the previous accuracy loop).
				rerk[j] = vread( rer, k+j);		reik[j] = vread( rei, k+j);		rork[j] = vread( ror, k+j);		roik[j] = vread( roi, k+j);
			}
			while (l<llim) {	// compute even and odd parts
				for (int j=0; j<NWAY; ++j)	q[0] += y0[j] * rerk[j];		// real even
				for (int j=0; j<NWAY; ++j)	q[1] += y0[j] * reik[j];		// imag even
				for (int j=0; j<NWAY; ++j) {
					y0[j] = vall(al[1])*(cost[j]*y1[j]) + vall(al[0])*y0[j];
				}
				for (int j=0; j<NWAY; ++j)	q[2] += y1[j] * rork[j];		// real odd
				for (int j=0; j<NWAY; ++j)	q[3] += y1[j] * roik[j];		// imag odd
				q+=4;
				for (int j=0; j<NWAY; ++j) {
					y1[j] = vall(al[3])*(cost[j]*y0[j]) + vall(al[2])*y1[j];
				}
				l+=2;	al+=4;
			}
			if (l==llim) {
				for (int j=0; j<NWAY; ++j)	q[0] += y0[j] * rerk[j];		// real even
				for (int j=0; j<NWAY; ++j)	q[1] += y0[j] * reik[j];		// imag even
			}
		  }
			k+=NWAY;
		} while (k < nk);
		l = LiM(shtns, m, im);
		v2d *Ql = (v2d*) &Qlm[l];
		#if _GCC_VEC_
			for (l=0; l<=llim-m; ++l) {
			#ifdef __AVX__
				rnd qa = _mm256_hadd_pd(qq[2*l], qq[2*l+1]);
				Ql[l] = _mm256_castpd256_pd128(qa) + _mm256_extractf128_pd(qa,1);
			#elif defined __SSE3__
				Ql[l] = _mm_hadd_pd(qq[2*l], qq[2*l+1]);
			#else
				s2d qa = _mm_unpacklo_pd(qq[2*l], qq[2*l+1]);		s2d qb = _mm_unpackhi_pd(qq[2*l], qq[2*l+1]);
				Ql[l] = qa + qb;
			#endif
			}
		#else
		#endif
		#ifdef SHT_VAR_LTR
			for (l=llim+1-m; l<=LMAX-m; ++l) {
				Ql[l] = vdup(0.0);
			}
		#endif
	}
	#ifdef SHT_VAR_LTR
	if (imlim < MMAX) {
		im = imlim+1;
		l = LiM(shtns, im*MRES, im);
		do {
			((v2d*)Qlm)[l] = vdup(0.0);
		} while(++l < shtns->nlm);
	}
	#endif

  	if (shtns->fftc_mode > 0) {		// free memory
	    VFREE(BrF - vnlat*imlim);
	}
  #endif

  }
